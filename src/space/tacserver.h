#pragma once
#include "space/tacspacetypes.h"
#include "space/tacspacenet.h"
#include "common/containers/tacVector.h"
#include <list>
#include <map>

struct TacOtherPlayer
{
  // A unique ID per players
  // ( both client players and server player ).
  // Generated by the server
  TacPlayerUUID mPlayerUUID = TacNullPlayerUUID;
  // Last acknowledged
  double mTimeStamp = 0;
  TacLagTest delayedNetMsg;
  TacConnectionUUID mConnectionUUID = TacNullConnectionUUID;
};

typedef void( *ServerSendNetworkMessageCallback )(
  TacConnectionUUID connectionID,
  void* bytes,
  int byteCount,
  void* userData );

struct TacReader;
struct TacWriter;
struct TacWorld;
struct TacEntity;
struct TacPlayer;
struct TacUser;
struct TacScriptRoot;

struct TacServerData
{
  TacServerData();
  ~TacServerData();
  TacEntity* SpawnEntity();
  TacPlayer* SpawnPlayer();
  void OnClientJoin( TacConnectionUUID connectionID );
  void DebugImgui();
  TacOtherPlayer* FindOtherPlayer( TacConnectionUUID connectionID );
  void ReceiveMessage(
    TacConnectionUUID connectionID,
    void* bytes,
    int byteCount,
    TacErrors& errors );
  void Update(
    float seconds,
    ServerSendNetworkMessageCallback sendNetworkMessageCallback,
    void* userData,
    TacErrors& errors );

  void OnLoseClient( TacConnectionUUID connectionID );

  void ReadInput(
    TacReader* reader,
    TacConnectionUUID connectionID,
    TacErrors& errors );

  void WriteSnapshotBody( TacOtherPlayer* otherPlayer, TacWriter* writer );

  void ExecuteNetMsg(
    TacConnectionUUID connectionID,
    void* bytes,
    int byteCount,
    TacErrors& errors );

  TacSnapshotBuffer mSnapshots;
  float mSnapshotUntilNextSecondsCur = 0;
  //TacChat mChat;
  TacWorld* mWorld = nullptr;
  TacWorld* mEmptyWorld = nullptr;
  static const int sOtherPlayerCountMax = 3;
  std::list< TacOtherPlayer* > mOtherPlayers;
  TacPlayerUUID mPlayerUUIDCounter = TacNullPlayerUUID;
  TacEntityUUID mEntityUUIDCounter = TacNullEntityUUID;
  //TacUser* mUser = nullptr;
};

extern const float sSnapshotUntilNextSecondsMax;

