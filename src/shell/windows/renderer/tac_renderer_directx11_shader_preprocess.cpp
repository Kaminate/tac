//#include "src/shell/windows/renderer/tac_renderer_directx11.h"
#include "src/common/graphics/tac_renderer.h"
#include "src/common/containers/tac_array.h"
#include "src/common/dataprocess/tac_text_parser.h"
#include "src/common/memory/tac_frame_memory.h"
#include "src/common/math/tac_math.h"
#include "src/common/core/tac_error_handling.h"

namespace Tac
{
  namespace Render
  {
    static struct
    {
      int Add( char c, int n )
      {
        const int iResource = mLetterCounts[ c ];
        mLetterCounts[ c ] += n;
        return iResource;
      }

      void Clear()
      {
        mLetterCounts = {};
      }
    private:
      Array< int, 128 > mLetterCounts;

    } sShaderRegisterMap;

    String PreprocessShaderSource( const StringView , Errors& );

    static bool IsSingleLineCommented( const StringView line )
    {
      ParseData shaderParseData( line.data(), line.size() );
      shaderParseData.EatWhitespace();
      return shaderParseData.EatStringExpected( "//" );
    }

    static String PreprocessShaderRegister( const StringView line )
    {
      const StringView autoRegister = "TAC_AUTO_REGISTER";
      const int iReplace = line.find( autoRegister );
      if( iReplace == line.npos )
        return line;

      const int regCount = [&]()
      {
        const int iOpen = line.find( '[' );
        const int iClose = line.find( ']' );
        if( iOpen == line.npos || iClose == line.npos )
          return 1;
        return ( int )ParseData( line.data() + iOpen + 1,
                                 line.data() + iClose ).EatFloat().GetValueUnchecked();
      }( );

      const StringView resourceTypeName = ParseData( line ).EatWord();
      const char resourceLetter = [ resourceTypeName ]()
      {
        if( resourceTypeName == "Texture2D" ||
            resourceTypeName == "Texture3D" )
          return 't';

        if( resourceTypeName == "cbuffer" )
          return 'b';

        if( resourceTypeName == "sampler" )
          return 's';

        return ( char )0;
      }( );
      TAC_ASSERT( resourceLetter );
      const int iResource = sShaderRegisterMap.Add( resourceLetter, regCount );

      String result;
      result += FrameMemoryPrintf( "// Autogenerated register from %s\n", __FUNCTION__ );
      result += line.substr( 0, iReplace );
      result += FrameMemoryPrintf( "register( %c%d )", resourceLetter, iResource );
      result += line.substr( iReplace + autoRegister.size() );
      return result;
    }

    static String PreprocessShaderIncludes( const StringView line, Errors& errors )
    {
      ParseData lineParseData( line.data(), line.size() );
      lineParseData.EatWhitespace();
      if( !lineParseData.EatStringExpected( "#include" ) )
        return line;
      lineParseData.EatUntilCharIsPrev( '\"' );
      const char*      includeBegin = lineParseData.GetPos();
      lineParseData.EatUntilCharIsNext( '\"' );
      const char*      includeEnd = lineParseData.GetPos();
      const StringView includeName( includeBegin, includeEnd );
      const String     includePath = Render::GetShaderPath( includeName );
      const String     includeSource = Render::ShaderPathToContentString( includePath, errors );
      const String     includeSourcePreproecssed = PreprocessShaderSource( includeSource, errors );
      String newLine;
      newLine += "//===----- (begin include " + includePath + ") -----===//\n";
      newLine += includeSourcePreproecssed;
      newLine += "//===----- (end include " + includePath + ") -----===//\n";
      return newLine;
    }

    static String PreprocessShaderSemanticName( const StringView line )
    {
      const int iAutoSemantic = line.find( "SV_AUTO_SEMANTIC" );
      if( iAutoSemantic == line.npos )
        return line;

      const int iColon = line.find( ":" );
      if( iColon == line.npos )
        return line;

      int iSemanticCharLast = iColon - 1;
      while( iSemanticCharLast > 0 && IsSpace( line[ iSemanticCharLast ] ) )
        iSemanticCharLast--;

      int iSemanticCharFirst = iSemanticCharLast;
      while( iSemanticCharFirst > 0 && !IsSpace( line[ iSemanticCharFirst - 1 ] ) )
        iSemanticCharFirst--;

      const String newLine
        = line.substr( 0, iAutoSemantic )
        + String( line.data() + iSemanticCharFirst, line.data() + iSemanticCharLast + 1 )
        + ";";

      return newLine;
    }

    static String PreprocessShaderFXFramework( const StringView line )
    {
      // At a base level, D3D11 only supports creating sampler states on the application side using D3D API calls.
      // Any HLSL code you've seen for defining sampler states was using the effects framework,
      // which is a higher-level library that sits on top of core D3D.
      // The effects framework actually reflects the sampler data from the compiled code,
      // and uses that reflected data to create and bind sampler states behind the scenes.
      // I really wouldn't recommend using the effects framework (it's old and no longer updated),
      // so you should just create and bind sampler states manually.
      // If necessary, you can always write your own layer for reflecting data from your shader and
      // using that to control binding of samplers and textures.
      //
      // ( quote from MJP 2014-07-19 on gamedev.net )

      const char* fxFrameworkStrs[] = { "SamplerState" }; // Are there more?
      for( const char* s : fxFrameworkStrs )
      {
        TAC_ASSERT_MSG( !line.contains( s ),
                        "%s is a deprecated directx fx framework feature and wont be supported in the newer "
                        "DXIL compiler. Create and bind your resources manually.",
                        s );
      }
      return line;
    }

    static String PreprocessShaderPadding( const StringView line )
    {
      const int iPad = line.find( "TAC_PAD_BYTES" );
      if( iPad == line.npos )
        return line;

      String numberStr;

      // Compiler literally decides to skip the string if we leave out these curly brackets
      for( char c : line ) { if( IsDigit( c ) ) { numberStr += c; } }

      const int padByteCount = Atoi( numberStr );
      TAC_ASSERT( !numberStr.empty() );
      TAC_ASSERT( padByteCount );
      TAC_ASSERT( padByteCount % 4 == 0 );

      static int padCounter;
      String result;
      String separator;
      for( int i = 0; i < padByteCount / 4; ++i )
      {
        result += separator;
        result += String( iPad, ' ' ) + "uint pad";
        result += ToString( padCounter++ );
        result += "; // Padding autogenerated by " + String( __FUNCTION__ );
        separator = "\n";
      }

      return result;
    }

    static String PreprocessShaderBitfield( const StringView line )
    {
      static int sRunningBitCount;
      static bool sProcessing;

      if( line.contains( "TAC_DEFINE_BITFIELD_BEGIN" ) )
      {
        TAC_ASSERT( !sProcessing );
        sProcessing = true;
        return "//   Bitfield getter functions auto generated by " + String( __FUNCTION__ );
      }

      if( line.contains( "TAC_DEFINE_BITFIELD_ELEMENT" ) )
      {
        TAC_ASSERT( sProcessing );

        const String functionName = [ & ]()
        {
          int iFunctionNameBegin = line.find( '(' ) + 1;
          while( IsSpace( line[ iFunctionNameBegin ] ) )
            iFunctionNameBegin++;
          int iFunctionNameEnd = line.find( ',' );
          return String( line.data() + iFunctionNameBegin,
                         line.data() + iFunctionNameEnd );
        }( );

        const int bitCount = [ & ]()
        {
          int iNumber = line.find( ',' ) + 1;
          while( IsSpace( line[ iNumber ] ) )
            ++iNumber;
          char c = line[ iNumber ];
          TAC_ASSERT( IsDigit( c ) );
          return c - '0';
        }( );

        const String space = [ & ]()
        {
          String result;
          for( char c : line )
          {
            if( IsSpace( c ) )
              result += c;
            else
              break;
          }
          return result;
        }( );

        const int oldRunningBitCount = sRunningBitCount;
        sRunningBitCount += bitCount;
        return FrameMemoryPrintf( "%suint %s( uint flags ) %s { return ( flags >> %i ) & 0x%02x; };",
                                  space.c_str(),
                                  functionName.c_str(),
                                  String( Max( 20 - functionName.size(), 0 ), ' ' ).c_str(),
                                  oldRunningBitCount,
                                  ( ( 1 << bitCount ) - 1 ) );

      }

      if( line.contains( "TAC_DEFINE_BITFIELD_END" ) )
      {
        TAC_ASSERT( sProcessing );
        sProcessing = false;
        sRunningBitCount = 0;
        return "";
      }

      return line;
    }

    static String PreprocessShaderLine( const StringView line, Errors& errors )
    {
      if( IsSingleLineCommented( line ) )
        return line;
      const String preprocessedLines[] =
      {
        PreprocessShaderRegister( line ),
        PreprocessShaderFXFramework( line ),
        PreprocessShaderIncludes( line, errors ),
        PreprocessShaderSemanticName( line ),
        PreprocessShaderPadding( line ),
        PreprocessShaderBitfield( line ),
      };

      for( const String& s : preprocessedLines )
      {
        if( s != line )
        {
          return PreprocessShaderSource( s, errors );
        }
      }
      return line;
    }

    String PreprocessShaderSource( const StringView shaderSourceCode, Errors& errors )
    {
      static int recurseCount;
      if( !recurseCount )
        sShaderRegisterMap.Clear();
      ++recurseCount;

      String result;
      ParseData shaderParseData( shaderSourceCode.data(), shaderSourceCode.size() );
      while( shaderParseData.GetRemainingByteCount() )
      {
        StringView line = shaderParseData.EatRestOfLine();
        result += PreprocessShaderLine( line , errors ) + "\n";
      }
      --recurseCount;
      return result;
    }

  } // namespace Render
} // namespace Tac



