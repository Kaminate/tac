#include "tac_hlsl_preprocess_padding.h" // self-inc

#include "tac-std-lib/string/tac_string.h" // String
#include "tac-std-lib/error/tac_assert.h" // TAC_ASSERT
//#include "tac-std-lib/preprocess/tac_preprocessor.h"

namespace Tac::Render
{
  static int GetPadByteCount( const StringView& line )
  {
    String numberStr;

    // Compiler literally decides to skip the string if we leave out these curly brackets
    for( char c : line )
    {
      if( IsDigit( c ) )
      {
        numberStr += c;
      }
    }

    TAC_ASSERT( !numberStr.empty() );

    const int padByteCount { Atoi( numberStr ) };
    TAC_ASSERT( padByteCount );
    TAC_ASSERT( padByteCount % 4 == 0 ); // <-- why?
    return padByteCount;
  }

  Optional<String> HLSLLinePreprocessorPadding::Preprocess( Input input, Errors& )
  {
    const StringView line{ input.mLine };
    if( !line.contains("TAC_PAD_BYTES") )
      return {};

    const int iPad { line.find( "TAC_PAD_BYTES" ) };
    const int padByteCount { GetPadByteCount( line ) };
    const int uintCount{ padByteCount / 4 };
    const int uintBase { mCounter };

    mCounter += uintCount;

    TAC_ASSERT( padByteCount % 4 == 0 );

    const String spaces( iPad, ' ' );

    String result;
    for( int i{}; i < padByteCount / 4; ++i )
    {
      const char* separator { i ? "\n" : "" };
      const String varName { "pad" + ToString( uintBase + i ) };

      result += separator;
      result += spaces + "uint ";
      result += varName;
      result += ";";
      if( !i )
        result += " // Padding autogenerated by " + String( __FUNCTION__ );
    }

    return result;
  }
} // namespace Tac::Render

